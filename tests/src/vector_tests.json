
{
	"Operator Overloads" : [
		{
			"tag" : "equality (identity)",
			"test" : "vec_a == vec_a"
		},
		{
			"tag" : "inequality (non-identity)",
			"test" : "vec_a != vec_b"
		},
		{
			"tag" : "negation (double negation)",
			"test" : "test_equal(-(-vec_a), vec_a)"
		},
		{
			"tag" : "addition (commutativity)",
			"test" : "test_equal(vec_a+vec_b, vec_b+vec_a)"
		},
		{
			"tag" : "addition (associativity)",
			"test" : "test_equal(vec_a+(vec_b+vec_c), (vec_a+vec_b)+vec_c)"
		},
		{
			"tag" : "addition (identity)",
			"test" : "test_equal(vec_a+vec_t(0), vec_a)"
		},
		{
			"tag" : "subtraction (anticommutativity)",
			"test" : "test_equal(vec_a-vec_b, -(vec_b-vec_a))"
		},
		{
			"tag" : "subtraction (nonassociativity)",
			"test" : "!test_equal(vec_a-(vec_b-vec_t(1)), (vec_a-vec_b)-vec_t(1))"
		},
		{
			"tag" : "subtraction (identity)",
			"test" : "test_equal(vec_a-vec_t(0), vec_a)"
		},
		{
			"tag" : "subtraction (negation)",
			"test" : "test_equal(vec_t(0)-vec_a, -vec_a)"
		},
		{
			"tag" : "multiplication (commutativity)",
			"test" : "test_equal(vec_a*vec_b, vec_b*vec_a)"
		},
		{
			"tag" : "multiplication (associativity)",
			"test" : "test_equal(vec_a*(vec_b*vec_c), (vec_a*vec_b)*vec_c)"
		},
		{
			"tag" : "multiplication (distributive)",
			"test" : "test_equal(vec_a*(vec_b+vec_c), vec_a*vec_b+vec_a*vec_c)"
		},
		{
			"tag" : "multiplication (identity)",
			"test" : "test_equal(vec_a*vec_t(1), vec_a)"
		},
		{
			"tag" : "multiplication (vec_t(0) property)",
			"test" : "test_equal(vec_a*vec_t(0), vec_t(0))"
		},
		{
			"tag" : "multiplication (negation)",
			"test" : "test_equal(-vec_t(1)*-vec_t(1)*vec_a, vec_a)"
		},
		{
			"tag" : "multiplication (inverse)",
			"test" : "test_equal(vec_a*(vec_t(1)/vec_a), vec_t(1))"
		},

		{
			"tag" : "division (right distributive)",
			"test" : "test_equal((vec_a+vec_b)/vec_c, vec_a/vec_c + vec_b/vec_c)"
		},
		{
			"tag" : "division (left antidistributive)",
			"test" : "!test_equal(vec_a/(vec_b+vec_c), vec_a/vec_b + vec_a/vec_c)"
		}

	],

	"Angle and Trigonometry Functions" : [
		{
			"tag" : "degrees / radians",
			"test" : "test_equal(degrees(radians(vec_a)), vec_a),"
		},
		{
			"tag" : "radians / degrees",
			"test" : "test_equal(radians(degrees(vec_a)), vec_a),"
		},
		{
			"tag" : "trigonometry (sin double inverse)",
			"test" : "test_equal(asin(sin(pi * vec_a/2)), pi * vec_a/2)"
		},
		{
			"tag" : "trigonometry (cos double inverse)",
			"test" : "test_equal(acos(cos(pi * vec_pos)), pi * vec_pos)"
		},
		{
			"tag" : "trigonometry (tan double inverse)",
			"test" : "test_equal(atan(tan(vec_a)), vec_a),"
		},
		{
			"tag" : "trigonometry hyperbolic (sinh double inverse)",
			"test" : "test_equal(asinh(sinh(pi * vec_a/2)), pi * vec_a/2)"
		},
		{
			"tag" : "trigonometry hyperbolic (cosh double inverse)",
			"test" : "test_equal(acosh(cosh(pi * vec_pos)), pi * vec_pos)"
		},
		{
			"tag" : "trigonometry hyperbolic (tanh double inverse)",
			"test" : "test_equal(atanh(tanh(vec_a)), vec_a),"
		},
		{
			"tag" : "trigonometry (quotient)",
			"test" : "test_equal(tan(vec_a), sin(vec_a)/cos(vec_a))"
		},
		{
			"tag" : "trigonometry (inverse quotient)",
			"test" : "test_equal(vec_t(1)/tan(vec_a), (vec_t(1)/sin(vec_a))/(vec_t(1)/cos(vec_a)))"
		},
		{
			"tag" : "trigonometry (sin-cos pythagorean)",
			"test" : "test_equal(sin(vec_a)*sin(vec_a) + cos(vec_a)*cos(vec_a), vec_t(1))"
		},
		{
			"tag" : "trigonometry (tan-sec pythagorean)",
			"test" : "test_equal(vec_t(1)+tan(vec_a)*tan(vec_a), (vec_t(1)/cos(vec_a))*(vec_t(1)/cos(vec_a)))"
		},
		{
			"tag" : "trigonometry (tan-sec pythagorean)",
			"test" : "test_equal(vec_t(1)+(vec_t(1)/tan(vec_a))*(vec_t(1)/tan(vec_a)), (vec_t(1)/sin(vec_a))*(vec_t(1)/sin(vec_a)))"
		}
	],

	"Exponential Functions" : [
		{
			"tag" : "pow (double, equality)",
			"test" : "test_equal(vec_a*vec_a, pow(vec_a, vec_t(2)))"
		},
		{
			"tag" : "pow (triple, equality)",
			"test" : "test_equal(vec_a*vec_a*vec_a, pow(vec_a, vec_t(3)))"
		},
		{
			"tag" : "exp / log (double inverse)",
			"test" : "test_equal(log(exp(vec_a)), vec_a)"
		},
		{
			"tag" : "exp / log (double inverse, reverse)",
			"test" : "test_equal(exp(log(vec_pos)), vec_pos)"
		},
		{
			"tag" : "exp2 / log2 (double inverse)",
			"test" : "test_equal(log2(exp2(vec_a)), vec_a)"
		},
		{
			"tag" : "exp2 / log2 (double inverse, reverse)",
			"test" : "test_equal(exp2(log2(vec_pos)), vec_pos)"
		},
		{
			"tag" : "pow / sqrt (double inverse)",
			"test" : "test_equal(sqrt(pow(vec_pos, vec_t(2))), vec_pos)"
		},
		{
			"tag" : "pow / sqrt (double inverse, reverse)",
			"test" : "test_equal(pow(sqrt(vec_pos), vec_t(2)), vec_pos)"
		},
		{
			"tag" : "sqrt / inversesqrt / abs (equality)",
			"test" : "test_equal(1/sqrt(vec_pos), inversesqrt(vec_pos))"
		}
	],

	"Common Functions" : [
		{
			"tag" : "abs  (absolute and negation)",
			"test" : "test_equal(abs(vec_a), abs(-vec_a))"
		},
		{
			"tag" : "sign (sign of vec_t(0) is vec_t(0))",
			"test" : "test_equal(sign(vec_t(0)), vec_t(0))"
		},
		{
			"tag" : "sign (sign multiplied by absolute)",
			"test" : "test_equal(sign(vec_a)*abs(vec_a), vec_a)"
		},
		{
			"tag" : "floor / all / lessThanEqual (less than equal floor)",
			"test" : "all(lessThanEqual(floor(vec_a), vec_a))"
		},
		{
			"tag" : "floor / fract (vec_t(0) fractional component)",
			"test" : "test_equal(fract(floor(vec_a)), vec_t(0))"
		},
		{
			"tag" : "ceil / all / greaterThanEqual (greater than equal floor)",
			"test" : "all(greaterThanEqual(ceil(vec_a), vec_a))"
		},
		{
			"tag" : "ceil / fract (vec_t(0) fractional component)",
			"test" : "test_equal(fract(ceil(vec_a)), vec_t(0))"
		},
		{
			"tag" : "mod scalar / fract (mod 1 fractional part)",
			"test" : "test_equal(mod(vec_pos+vec_t(1), so), fract(vec_pos))"
		},
		{
			"tag" : "mod vector / fract (mod 1 fractional part)",
			"test" : "test_equal(mod(vec_pos+vec_t(1), vec_t(1)),  fract(vec_pos))"
		},
		{
			"tag" : "min scalar (less than equality)",
			"test" : "all(lessThanEqual(min(vec_a,sa), vec_a)) && all(lessThanEqual(min(vec_a,sa), vec_t(sa)))"
		},
		{
			"tag" : "min vector (less than equality)",
			"test" : "all(lessThanEqual(min(vec_a,vec_b), vec_a)) && all(lessThanEqual(min(vec_a,vec_b), vec_b))"
		},
		{
			"tag" : "max scalar (greater than equality)",
			"test" : "all(greaterThanEqual(max(vec_a,sa), vec_a)) && all(greaterThanEqual(max(vec_a,sa), vec_t(sa)))"
		},
		{
			"tag" : "max vector (greater than equality)",
			"test" : "all(greaterThanEqual(max(vec_a,vec_b), vec_a)) && all(greaterThanEqual(max(vec_a,vec_b), vec_b))"
		},
		{
			"tag" : "min / max scalar (summation equality)",
			"test" : "test_equal(min(vec_a,sa)+max(vec_a,sa),  vec_a+sa)"
		},
		{
			"tag" : "min / max vector (summation equality)",
			"test" : "test_equal(min(vec_a,vec_b)+max(vec_a,vec_b),  vec_a+vec_b)"
		},
		{
			"tag" : "mix scalar (identity)",
			"test" : "test_equal(mix(vec_a, vec_a, sa), vec_a)"
		},
		{
			"tag" : "mix scalar (summation equality)",
			"test" : "test_equal(mix(vec_a, vec_b, sa) + mix(vec_b, vec_a, sa), vec_a+vec_b)"
		},
		{
			"tag" : "mix scalar (identity)",
			"test" : "test_equal(mix(vec_a, vec_a, vec_pos), vec_a)"
		},
		{
			"tag" : "mix scalar (summation equality)",
			"test" : "test_equal(mix(vec_a, vec_b, vec_pos) + mix(vec_b, vec_a, vec_pos), vec_a+vec_b)"
		}
	],


	"Geometric Functions" : [
	],


	"Relational Functions" : [
		{
			"tag" : "all lessThan / greaterThanEqual (exclusivity)",
			"test" : "all(notEqual(lessThan(vec_a, vec_b), greaterThanEqual(vec_a, vec_b)))"
		},
		{
			"tag" : "all lessThanEqual / greaterThan (exclusivity)",
			"test" : "all(notEqual(lessThanEqual(vec_a, vec_b), greaterThan(vec_a, vec_b)))"
		}
	]
}